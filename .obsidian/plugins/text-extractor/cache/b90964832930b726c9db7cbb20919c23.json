{"path":"Software Engineering/Studying/Year 2/Semester 1/Past Papers/SP/sp_2022.pdf","text":"Anytime before the actual exam Your real exam is 8/9 Feb! Expected Duration: 1 hour 30 minutes (expected in 2022, to conﬁrm) Time Allowed: 3 hours (expected in 2022, to conﬁrm) Timed exam within 24 hours DEGREE of BSc Software Engineering (Graduate Apprenticeship) SYSTEMS PROGRAMMING COMPSCI 2030 (Answer all 4 questions. This is a mock exam, v20220123) This examination paper is an open book, online assessment and is worth a total of 90 marks. 1. These multiple-choice questions are negatively marked. For each correct answer you gain three marks, and for each wrong answer, you lose one. There is one correct answer per question. There are 30 total marks in this question. (a) Which of the following would require the most memory in standard C? 1. float 2. long int 3. char 4. double [3] (b) How are new types deﬁned in C? 1. We use the typedef keyword 2. Types cannot be deﬁned, only imported 3. We use the deftype keyword 4. C doesn’t allow new types [3] (c) Which of the following is true about C pointers? 1. C pointers only come from malloc(), calloc(), and realloc() 2. Functions cannot return pointers 3. Pointer size depends on the system running our code 4. Any pointer returned by a function must be void [3] (d) We cannot allocate heap memory using: 1. malloc() 2. calloc() 3. realloc() 4. free() [3] (e) Stack memory is: 1. Unsafe to return the address of from a function 2. Allocated using malloc() 3. A method used by the operating system to allocate memory in pages 4. A modern memory management technique for deallocating space automatically, which C does not have 1 CONTINUED OVERLEAF [3] (f) A use-after-free error is caused by: 1. free()-ing memory twice 2. Accessing a value at a previously free()-d address 3. Losing reference to a pointer to heap-allocated memory 4. Running out of space to store values in memory [3] (g) Assume arr is an array of ints, and index is a valid integer index in arr. One of the following snippets has a different value to the others. Which one? 1. index[arr] 2. arr[index] 3. (index + arr) 4. *(index + arr) [3] (h) A race condition can occur when: 1. Two or more threads wait indeﬁnitely on a lock held by another 2. Two or more threads access the same memory location at the same time 3. Two or more threads return a value at the same time 4. Two or more threads process copies of the same values [3] (i) Which of the following is true of threads?: 1. A thread is created and managed by an operating system 2. A thread is independent of the process which started it 3. A thread has heap memory separate to that of other threads 4. A thread is a language construct managed by a runtime, rather than the operating system itself [3] (j) pthread_join() is a function used to: 1. Signal that a thread should terminate 2. Signal the most important thread to the operating system, for scheduling purposes 3. Ensure safe access in a critical region 4. Wait for a thread to ﬁnish executing [3] 2 CONTINUED OVERLEAF 2. These questions will center around code comprehension. Each snippet of code is completely self-contained, meaning that what you read should compile without warnings or errors without additions. However, in each question there will be an error regarding the use of C, an error pertaining to memory, or an error caused by mismanaged concurrency. For each question, you should: 1. Identify the bug in the code, and 2. Suggest a ﬁx. There are 21 total marks in this question. (a) 1 #include <stdio.h> 2 3 typedef struct _book { 4 char title[50]; 5 int timesRead; 6 } book; 7 8 void printBook(book *toPrint) { 9 printf(\"You have read %s %d times.\\n\", 10 toPrint.title, toPrint.timesRead); 11 } 12 13 int main() { 14 book goodBook = {\"House of Leaves\", 0}; 15 goodBook->timesRead++; 16 goodBook->timesRead++; 17 printBook(&goodBook); 18 return 0; 19 } [7] (b) 1 #include <stdio.h> 2 3 void calc_next_collatz(int *num) { 4 if (num % 2 == 0) { 5 num /= 2; 6 } else { 7 num = num * 3 + 1; 8 } 9 } 10 11 int main() { 12 int x = 6; 13 while (x != 1) { 14 calc_next_collatz(&x); 15 printf(\" -> %d\", x); 3 CONTINUED OVERLEAF 16 } 17 printf(\"\\n\"); 18 19 } [5] (c) 1 #include <pthread.h> 2 #include <stdio.h> 3 #include <stdlib.h> 4 #include <string.h> 5 6 7 void * printInfo(void * arg) { 8 char * user_input = (char *) arg; 9 10 long int len = strlen(user_input); 11 printf(\"Argument %s has length %ld\\n\", user_input, len); 12 13 pthread_exit(&len); 14 } 15 16 int main(int argc, char * argv[]) { 17 18 pthread_t * threads = malloc(argc * sizeof(pthread_t)); 19 int i; 20 for (i = 0; i < argc; i++) { 21 pthread_create(&threads[i], NULL, printInfo, argv[i]); 22 } 23 24 long int ** lengths = malloc(argc * sizeof(int *)); 25 26 for (i = 0; i < argc; i++) { 27 pthread_join(threads[i], (void *)&lengths[i]); 28 } 29 30 long int total = 0; 31 for (i = 0; i < argc; i++) { 32 total += *lengths[i]; 33 } 34 printf(\"\\n\\nTotal length is %ld\\n\", total); 35 36 return 0; 37 } [7] 4 CONTINUED OVERLEAF 3. These questions require longform answers. There are 23 total marks available. (a) (i) Brieﬂy explain the difference between stack and heap memory. Explain whether each one is speciﬁc to a thread, a process, both, or neither. [4] (ii) Can a memory leak happen to stack-allocated memory? Why, or why not? [2] (iii) One of the design decisions in C++ which diverges from C’s design is its use of a technique called RAII. What does this acronym stand for, and in what way does it help memory management in C++? [4] (b) When freeing memory, fragmentation can occur, where small chunks of memory are left unused, but cannot be allocated because of their size and proximity to allocated blocks of memory. What operating system feature mitigates memory fragmentation? [2] (c) Brieﬂy explain what POSIX is, why one might write POSIX-compliant code, and an example of when an operating system being non-POSIX-compliant impacts code portability. [6] (d) (i) What causes a race condition? [2] (ii) Race conditions can be defended against using a concurrency primitive which, when used incorrectly, causes a deadlock. What is the name of this concurrency primitive, and how can its misuse cause a deadlock? [3] 5 CONTINUED OVERLEAF 4. Explain the signiﬁcance of each line of the program on the following page commented with ???. What do i and c do? What will this code print when run? This question is worth 16 marks. 6 CONTINUED OVERLEAF 1 #include <stdio.h> 2 #include <stdlib.h> 3 4 typedef struct _n { 5 int val; 6 struct _n * l; 7 struct _n * r; 8 } n; 9 10 void c(n * p, int v, int r) { 11 n * new = malloc(sizeof(n)); // ??? 1 12 new->l = NULL; 13 new->r = NULL; 14 new->val = v; 15 if (r) { // ??? 2 16 p->r = new; 17 } else { 18 p->l = new; 19 } 20 } 21 22 int i(n * r, int e) { 23 if (e == r->val) { // ??? 3 24 return 0; 25 } else if (e < r->val) { 26 if (r->l == NULL) { 27 c(r, e, 0); // ??? 4 28 return 1; 29 } else { 30 return i(r->l, e); // ??? 5 31 } 32 } else { 33 if (r->r == NULL) { 34 c(r, e, 1); 35 return 1; 36 } else { 37 return i(r->r, e); 38 } 39 } 40 } 41 42 int main() { 43 n r = {5, NULL, NULL}; 44 i(&r, 2); 45 i(&r, 5); 46 i(&r, 8); 47 i(&r, 3); 48 } [16] 7 END OF QUESTION PAPER","libVersion":"0.3.2","langs":""}