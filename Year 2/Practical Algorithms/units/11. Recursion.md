**Slides**
- [[13. Recursion.pdf]]

We've already implemented something like this in: [[2. Analyzing Algorithms]]

- ***Is when a function makes a call to itself***
- ***We keep defining the problem as simpler versions of itself until we get to the base case.***
- ***It works only if***
	- ***There is a base case defined***
	- ***Parameters of the function on successive calls change.***

**Classic example: the factorial function:**

```python
def factorial(n):
	if (n == 1):
		return 1
	else:
		return n * factorial(n-1)

print(factorial(4))
```

We have implemented the factorial function as a recursive algo.

# General Principles for Recursive Algorithms

- When calling itself, a recursive function makes a clone and calls the clone with appropriate parameters.

- A recursive algorithm must always:
	-  **Rule 1**: Reduce the size of the input, each time it is recursively called.
	-  **Rule 2**: provide a stopping case (terminating condition)

# Writing Recursive Functions â€“ Tips

Write the base case first 
- For the rest of the cases, work out how to "reduce" them to simpler cases
	- Arguments/input should "converge" towards the base case 

- Think/visualize in terms of small problem sizes (e.g. FACTORIAL(3))
	- Confirm that the base case works
	- Confirm that these specific, small non-base-case cases work
	- "Convince" yourself that generalizing to arbitrary input sizes will work!

- [ ] ðŸ”½ **Review this section from the book**: <http://openbookproject.net/thinkcs/python/english3e/recursion.html>

# Linear and Binary Recursion

---
## Linear Recursion
**At most one recursive call at each invocation.**

The amount of space needed, to keep track of all nested calls, grows linearly (wrt the size of the input) 
- The recursion trace is a visualization of space requirements 

Example: FACTORIAL(n) 
- A single recursive call to FACTORIAL(n-1)

```python
def factorial(n):
	if (n == 1):
		return 1
	else:
		return n * factorial(n - 1)

print(factorial(10))
```

---
## Binary Recursion
**When an algorithm makes two recursive calls, we say that it uses binary recursion.**
- To solve two halves of some problem

Classic example: Fibonacci numbers are a sequence of numbers defined by 
- Every number in the sequency is the sum of previous two numbers 
- $F_n = F_{n-1} + F_{n-2}$ for $n > 1$ with $F_0 = 0$ and $F_1 = 1$

```python
import functools

@functools.cache
def fibonacci(n):
	if (n <= 1):
		return n
	else: 
		return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(4))
```

---
