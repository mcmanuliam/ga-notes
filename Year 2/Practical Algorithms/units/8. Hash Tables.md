**Slides:**
- [[10. Hashmaps.pdf]]
## Hashing: Overview

![[Pasted image 20241115103529.png]]


- Generalizes direct-address tables by adding a hash function
- Consists of: 
	1. An array T[0,..,m - 1] of fixed size m (called hash table or bucket array)
	2. A hash function h: U → {0,1,…,m - 1} mapping keys to slots of T 

- Hash collision: when two keys are mapped to the same slot of the hash table 
	- That is, h(k1)=h(k2) for k1≠k2 (where k1,k2 ∈ U)
	- In general, hash collisions are unavoidable (if |U| > m)
	- However: a "good" hash function spreads keys as "evenly" as possible over the slots of **T**
		- Each backet should be used with equal probability for data randomly sampled from the universe U 
	
- Additionally: hash functions should be "simple" and fast to compute 
- Under the above assumptions: hash tables support INSERT, DELETE and SEARCH operations in O(1) time "on average"

### Encoding General Keys as Natural Numbers
- Most hash functions operate on natural numbers, ie they assume as a universe of keys U = ℕ

 - There are several methods (called hash codes) to convert/encode an arbitrary object as a natural number, e.g.
	 - Integer casting
	 - Component sum
	 - Memory address
	 - Polynomial hashing
	
- Here we will only describe integer casting and component sum here, very briefly

#### Truncation
- Take the first/last few digits of the key
	- Problem: it may generate many collisions if there are regularities in the input keys

- Example
	- Student IDs consisting of 8 digits: 2023 1734 
	- Numbers are assigned sequentially
	- Students in a given class/year will tend to have IDs close together, and all beginning with the same first few digits
	- But: taking the last three digits will work a lot better

#### Division
- Map a key k into one of m slots by taking the remainder of the division of k by m
	- The hash function is h(k) = k mod m 
		- Python: k % m
	
- ***Good practice: to ensure that data is distributed fairly, we usually choose the table size m to be***
	- Prime
	- Not "too close" to an exact power of 2

- If m = 2p, then h(k) is just the p lowest-order bits of k 
	- Examples: 
$$ 101011_{2} \% 102 = 12, 101011_{2} \% 100_{2} = 11_{2} $$
	The analogous case for decimal numbers would be division by powers of 10: $$234_{10} \% 10_{10} = 4_{10}, 234_{10} \% 100_{10} = 34_{10}$$
	 If use of lower-order bits is suitable, better to simply truncate

#### Hashing by Division

- Suppose we want to allocate a hash table to hold roughly 5000 keys

- We pick m to be a prime close to 5000 but not near any power of 2
	- 212 = 4069 
	- 213 = 8192
	
- Primes near 5000: − 4987, 4993, 4999, 5003, 5009, 5011 • So, our hash function could be h(k) = k mod 500